== Memory-mapped register interface

The IOMMU provides a memory-mapped programming interface. The memory-mapped 
registers of each IOMMU are located within a naturally aligned 4-KiB region 
(a page) of physical address space. 

The IOMMU behavior for register accesses where the address is not aligned to 
the size of the access or if the access spans multiple registers is undefined.

The reset default value of register fields is 0 unless explicitly noted 
otherwise in the register definition.

Register fields are assigned one of the attributes described in following 
table.

.Register and Register bit-field types
[width=90%]
[%header, cols="^3, 10"]
|===
^|Attribute    ^|                      Description
| RW            | Read-Write - Register bits are read-write and are permitted 
                  to be either Set or Cleared by software to the desired state.

                  If the optional feature that is associated with the bits is 
                  not implemented, the bits are permitted to be hardwired to
                  Zero.
| RO            | Read-only - Register bits are read-only and cannot be altered
                  by software. Where explicitly defined, these bits are used
                  to reflect changing hardware state, and as a result bit 
                  values can be observed to change at run time.

                  If the optional feature that would Set the bits is not 
                  implemented, the bits must be hardwired to Zero
| RW1C          | Write-1-to-clear status - Register bits indicate status when 
                  read. A Set bit indicates a status event which is Cleared by
                  writing a 1b. Writing a 0b to RW1C bits has no effect.

                  If the optional feature that would Set the bit is not 
                  implemented, the bit must be read-only and hardwired to Zero
| WPRI          | Reserved Writes Preserve Values, Reads Ignore Values. See
                  RISC-V privileged specification for a detailed definition.
| WARL          | Write Any Values, Reads Legal Values. See RISC-V privileged 
                  specification for a detailed definition.
|===


=== Register layout

.IOMMU Memory-mapped register layout
[width=90%]
[%header, cols="^3,6,^3, 18"]
|===
|Offset|Name            |Size|Description
|0     |`capability`    |8   |<<CAP, Capabilities supported by the IOMMU>>
|8     |For custom use  |8   |For custom use
|16    |`ddtp`          |8   |<<DDTP, Device directory table pointer>>
|24    |`cqb`           |8   |<<CQB, Command-queue base>>
|32    |`cqh`           |4   |<<CQH, Command-queue head>>
|36    |`cqt`           |4   |<<CQT, Command-queue tail>>
|40    |`fqb`           |8   |<<FQB, Fault-queue base>>
|48    |`fqh`           |4   |<<FQH, Fault-queue head>>
|52    |`fqt`           |4   |<<FQT, Fault-queue tail>>
|56    |`pqb`           |8   |<<PQB, Page-request-queue base>>
|64    |`pqh`           |4   |<<PQH, Page-request-queue head>>
|68    |`pqt`           |4   |<<PQT, Page-request-queue tail>>
|72    |`cqcsr`         |4   |<<CSR, Command-queue control and status register>>
|76    |`fqcsr`         |4   |<<FQCSR, Fault-queue control and status register>>
|80    |`pqcsr`         |4   |<<PQCSR, Page-request-queue control 
                                     and status register>>
|84    |`ipsr`          |4   |<<IPSR, Interrupt pending status register>>
|88    |`iocntovf`      |4   |<<OVF, PMU overflow status register.>>
|92    |`iocntinh`      |4   |<<INH, PMU counter inhibit register>>
|96    |`iohpmcycles`   |8   |<<CYC, IOMMU hardware-perf. monitoring 
                                     cycles counter>>
|104   |`iohpmctr1 - 31`|248 |<<CTR, IOMMU hardware-performance monitoring 
                                     counters>>
|352   |`iohpmevt1 - 31`|248 |<<EVT, IOMMU hardware-performance monitoring 
                                     events>>
|600   |`iocntsec`      |4   |<<SEC, Counters reserved for secure mode usage>>
|604   |Reserved`       |78  |Reserved for future use (`WPRI`)
|682   |Custom          |78  |Reserved for custom use (`WARL`)
|760   |`icvec`         |4   |<<ICVEC, Interrupt cause to vector register>>
|768   |`msi_tbl`       |256 |<<MSI, MSI Table>>
|1024  |Reserved        |3072|Reserved for future use (`WPRI`)
|===


[[CAP]]
=== IOMMU capabilities (`capabilities`)

The `capabilities` is a WARL read-write register reporting features supported
by the IOMMU. Each field if not clear indicates presence of that feature in 
the IOMMU. At reset, the register shall contain the maximal supported features.

This register must be readable in any implementation. An implementation may 
allow one or more fields in the register to be writeable to support enabling
or disabling the feature corresponding to that field.

If a `capabilities` field is writeable then the corresponding feature may be 
enabled or disabled by updating that field. If a feature `x` depends on a 
feature `y`, then attempting to enable feature `x` but disable feature `y` 
results in both features being disabled.

An implementation may impose additional constraints on the collective setting 
of two or more `capabilities` fields, in which case they function collectively 
as a single WARL field. An attempt to write an unsupported combination causes 
those bits to be set to some supported combination.

When software enables an feature that was previously disabled, then all state
associated with that feature is `UNSPECIFIED`, unless otherwise specified by 
that feature.

When software enables or disables a feature when the IOMMU is not OFF 
(i.e. `ddtp.MODE == Off`) then the IOMMU behavior is `UNSPECIFIED`.

.capabilities register fields
[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'version'},
  {bits: 1, name: 'Sv32'},
  {bits: 1, name: 'Sv39'},
  {bits: 1, name: 'Sv48'},
  {bits: 1, name: 'Sv57'},
  {bits: 1, name: '4xSv32'},
  {bits: 1, name: '4xSv39'},
  {bits: 1, name: '4xSv48'},
  {bits: 1, name: '4xSv57'},
  {bits: 1, name: 'Svnapot'},
  {bits: 1, name: 'Svpbmt'},
  {bits: 1, name: 'MSI'},
  {bits: 1, name: 'MSI_MRIF'},
  {bits: 1, name: 'AMO'},
  {bits: 1, name: 'ATS'},
  {bits: 1, name: 'T2GPA'},
  {bits: 1, name: 'END'},
  {bits: 1, name: 'WIS'},
  {bits: 1, name: 'PMON'},
  {bits: 22, name: 'reserved'},
  {bits: 16, name: 'custom'},
], config:{lanes: 8, hspace:1024}}
....

[width=100%]
[%header, cols="1,1,1,6"]
|===
|Bits  |Field      |Attribute | Description
|7:0   |`version`  |RO        | The `version` field holds the version of the 
                                specification implemented by the IOMMU. The low
                                nibble is used to hold the minor version of the
                                specification and the upper nibble is used to 
                                hold the major version of the specification. 
                                For example, an implementation that supports 
                                version 1.0 of the specification reports 0x10.
|8     |`Sv32`     |WARL      | Page-based 32-bit virtual-memory system
|9     |`Sv39`     |WARL      | Page-based 39-bit virtual-memory system 
|10    |`Sv48`     |WARL      | Page-based 48-bit virtual-memory system 
|11    |`Sv57`     |WARL      | Page-based 57-bit virtual-memory system 
|12    |`Sv32`     |WARL      | Page-based 34-bit virtual addressing (G-stage)
|13    |`Sv39`     |WARL      | Page-based 39-bit virtual addressing (G-stage)
|14    |`Sv48`     |WARL      | Page-based 48-bit virtual addressing (G-stage)
|15    |`Sv57`     |WARL      | Page-based 57-bit virtual addressing (G-stage)
|16    |`Svnapot`  |WARL      | NAPOT translation contiguity
|17    |`Svpbmt`   |WARL      | Page-based memory types
|18    |`MSI`      |WARL      | MSI address translation using Write-through 
                                mode MSI PTE
|19    |`MSI_MRIF` |WARL      | MSI address translation using MRIF mode MSI PTE
|20    |`AMO`      |WARL      | Atomic updates to MRIF and PTE accessed (A) 
                                and dirty (D) bit
|21    |`ATS`      |WARL      | PCIe Address Translation Services (ATS) and 
                                page-request interface (PRI)
|22    |`T2GPA`    |WARL      | Returning guest-physical-address in ATS 
                                translation completions.
|23    |`END`      |WARL      | When 0, IOMMU accesses to memory resident data 
                                structures (e.g. DDT, PDT, in-memory queues, 
                                VS and G stage page tables) are performed as 
                                little-endian accesses and when 1 as 
                                big-endian accesses.
|24    |`WIS`      |WARL      | IOMMU interrupts signaled as wired-interrupts
|25    |`PMON`     |WARL      | IOMMU implements a performance-monitoring unit
|47:26 |`reserved` |WPRI      | Reserved for standard use
|63:48 |`custom`   |WARL      | Reserved for custom use
|===

[NOTE]
====
Hypervisor may provide an SW emulated IOMMU to allow the guest to manage 
the VS-stage page tables for fine grained control on memory accessed by guest 
controlled devices. 

A hypervisor that provides such an emulated IOMMU to the guest may retain 
control of the G-stage page tables and clear the `4xSv32`, `4xSv39`, `4xSv48`, 
and `4xSv57` fields of the emulated `capabilities` register.

A hypervisor that provides such an emulated IOMMU to the guest may retain 
control of the MSI page tables used to direct MSI to guest interrupt files in 
an IMSIC or to a memory-resident-interrupt-file and clear the `MSI` and 
`MSI_MRIF` fields of the emulated `capabilities` register.
====

=== Device-directory table pointer (`ddtp`)

[[CQB]]
=== Command-queue base (`cqb`)

This 64-bits register (RW) holds the PPN of the root page of the command-queue
and number of entries in the queue.

.Command-queue base register fields
[wavedrom, , ]
....
{reg: [
  {bits:  5, name: 'LOG2SZ-1'},
  {bits: 44, name: 'PPN'},
  {bits: 15, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field      |Attribute | Description
|4:0   |`LOG2SZ-1` |WARL     a| The `LOG2SZ-1` field holds the number of 
                                entries in command-queue as a log to base 2 
                                minus 1. 
                                A value of 0 indicates a queue of 2 entries.
                                Each IOMMU command is 16-bytes. 
                                If the command-queue has 256 or fewer entries 
                                then the base address of the queue is always 
                                aligned to 4-KiB. If the command-queue has more
                                than 256 entries then the command-queue 
                                base address must be naturally aligned to 
                                `2^LOG2SZ^ x 16`.
|48:5  |`PPN`      |WARL      | Holds the `PPN` of the root page of the 
                                in-memory command-queue used by software to 
                                queue commands to the IOMMU. 
|63:49 |`WPRI`     |WPRI      | Reserved
|===

[[CQH]]
=== Command-queue head (`cqh`)

This 32-bits register (RO) holds the index into the command-queue where 
the IOMMU will fetch the next instruction.

.Command-queue head register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the command-queue from where
                            the next command will be fetched next by the IOMMU.
|===

[[CQT]]
=== Command-queue tail (`cqt`)

This 32-bits register (RW) holds the index into the command-queue where 
the software queues the next command for the IOMMU.

.Command-queue tail register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |WARL      | Holds the `index` into the command-queue where 
                            software queues the next command for IOMMU.  Only 
                            `LOG2SZ:0` bits are writeable when the queue is 
                            in enabled state (i.e., `cqsr.cqon == 1`).
|===

[[FQB]]
=== Fault queue base (`fqb`)

This 64-bits register (RW) holds the PPN of the root page of the fault-queue
and number of entries in the queue.

.Fault queue base register fields

[wavedrom, , ]
....
{reg: [
  {bits: 5, name: 'LOG2SZ-1'},
  {bits: 44, name: 'PPN'},
  {bits: 15, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field     |Attribute | Description
|4:0   |`LOG2SZ-1`|WARL     a| The `LOG2SZ-1` field holds the number of 
                               entries in fault-queue as a log-to-base-2 
                               minus 1. A value of 0 indicates a queue of 2 
                               entries. Each fault record is 64-bytes. 
                               If the fault-queue has 64 or fewer entries then 
                               the base address of the queue is always aligned 
                               to 4-KiB. If the fault-queue has more than 64 
                               entries then the fault-queue base address must 
                               be naturally aligned to `2^LOG2SZ^ x 64`.
|48:5  |`PPN`     |WARL      | Holds the `PPN` of the root page of the 
                               in-memory fault-queue used by IOMMU to queue 
                               fault record.
|63:49 |`WPRI`    |WPRI      | Reserved
|===

[[FQH]]
=== Fault queue head (`fqh`)

This 32-bits register (RW) hodlds the index into fault-queue where the
software will fetch the next fault reccord.

.Fault queue head register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute |Description
|31:0 |`index` |WARL      | Holds the `index` into the fault-queue from which 
                            software reads the next fault record.  Only 
                            `LOG2SZ:0` bits are writeable when the queue is 
                            in enabled state (i.e., `fqsr.fqon == 1`).
|===

[[FQT]]
=== Fault queue tail (`fqt`)

This 32-bits register (RO) holds the index into the fault-queue where the
IOMMU queues the next fault record.

.Fault queue tail register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the fault-queue where IOMMU 
                            writes the next fault record.
|===

[[PQB]]
=== Page-request-queue base (`pqb`)

This 64-bits register (RW) holds the PPN of the root page of the 
page-request-queue and number of entries in the queue.

.Page-Request-queue base register fields

[wavedrom, , ]
....
{reg: [
  {bits: 5, name: 'LOG2SZ-1'},
  {bits: 44, name: 'PPN'},
  {bits: 15, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field     |Attribute | Description
|4:0   |`LOG2SZ-1`|WARL      | The `LOG2SZ-1` field holds the number of entries 
                               in page-request-queue as a log-to-base-2 minus 1.
                               A value of 0 indicates a queue of 2 entries. 
                               Each page-request is 16-bytes. If the 
                               page-request-queue has 256 or fewer entries 
                               then the base address of the queue is always 
                               aligned to 4-KiB.
                               If the page-request-queue has more than 256 
                               entries then the page-request-queue base address
                               must be naturally aligned to `2^LOG2SZ^ x 16`.
|48:5  |`PPN`     |WARL      | Holds the `PPN` of the root page of the 
                               in-memory page-request-queue used by IOMMU to 
                               queue page requests.
|63:49 |`WPRI`    |WPRI      | Reserved
|===

[[PQH]]
=== Page-request-queue head (`pqh`)

This 32-bits register (RW) holds the index into the page-request-queue where
software will fetch the next page-request.

.Page-request-queue head register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |WARL      | Holds the `index` into the page-request-queue from 
                            which software reads the next page request.  Only 
                            `LOG2SZ:0` bits are writeable when the queue is 
                            inenabled state (i.e., `pqsr.pqon == 1`).
|===

[[PQT]]
=== Page-request-queue tail (`pqt`)

This 32-bits register (RO) holds the index into the page-request-queue 
where the IOMMU writes the next page-request.

.Page-request-queue tail register fields

[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'index'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|31:0 |`index` |RO        | Holds the `index` into the page-request-queue 
                            where IOMMU writes the next page request.
|===

[[CSR]]
=== Command-queue CSR (`cqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the command-queue.

.Command-queue CSR register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'cqen'},
  {bits: 1, name: 'cie'},
  {bits: 6, name: 'WPRI'},
  {bits: 1, name: 'cqmf'},
  {bits: 1, name: 'cmd_to'},
  {bits: 1, name: 'cmd_ill'},
  {bits: 1, name: 'fence_w_ip'},
  {bits: 4, name: 'WPRI'},
  {bits: 1, name: 'cqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'WPRI'},
  {bits: 4, name: 'Custom use'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits |Field   |Attribute | Description
|0    |`cqen`  |RO        | The command-queue-enable bit enables the command-
                            queue when set to 1. Changing `cqen` from 0 to 1
                            sets the `cqh`, `cqt` to 0 and sets cqcsr bits 
                            `cmd_ill`, `cmd_to`, `cqmf`, `fence_w_ip` to 0. 
                            The command-queue may take some time to be active 
                            following setting the `cqen` to 1. When the command 
                            queue is active, the `cqon` bit reads 1.

                            When `cqen` is changed from 1 to 0, the command 
                            queue may stay active till the commands already 
                            fetched from the command-queue are being processed 
                            and/or there are outstanding implicit loads from 
                            the command-queue.  When the command-queue turns 
                            off, the `cqon` bit reads 0.

                            When the `cqon` bit reads 0, the IOMMU guarantees 
                            that no implicit memory accesses to the command 
                            queue are in-flight and the command-queue will not 
                            generate new implicit loads to the queue memory. 
|1    |`cie`   |RW        | Command-queue-interrupt-enable bit enables 
                            generation of interrupts from command-queue when 
                            set to 1.
|7:2  |`WPRI`  |WPRI      | Reserved
|8    |`cqmf`  |RW1C      | If command-queue access lead to a memory fault then
                            the command-queue-memory-fault bit is set to 1 and 
                            the command-queue stalls until this bit is cleared. 
                            When `cqmf` is set to 1, an interrupt is generated 
                            if an interrupt is not already pending 
                            (i.e., `ipsr.cip == 1`) and not masked 
                            (i.e. `cqsr.cie == 0`). To re-enable command 
                            processing software should clear this bit by 
                            writing 1. 
|9    |`cmd_to`|RW1C      | If the execution of an instruction leads to a 
                            timeout (e.g. a command to invalidate device ATC 
                            may timeout waiting for a completion), then the 
                            command-queue sets the `cmd_to` bit and stops 
                            processing from the command-queue. When `cmd_to` is
                            set to 1 an interrupt is generated if an interrupt 
                            is not already pending (i.e., `ipsr.cip == 1`) and 
                            not masked (i.e. `cqsr.cie == 0`). To re-enable 
                            command processing software should clear this bit 
                            by writing 1. 
|10   |`cmd_ill`|RW1C     | If an illegal or unsupported command is fetched and
                            decoded by the command-queue then the command-queue 
                            sets the `cmd_ill` bit and stops processing from the
                            command-queue. When `cmd_ill` is set to 1, 
                            an interrupt is generated if not already pending 
                            (i.e. `ipsr.cip == 1`) and not masked 
                            (i.e.  `cqsr.cie == 0`). To re-enable command 
                            processing software should clear this bit by 
                            writing 1. 
|11   |`fence_w_ip`|RW1C  | An IOMMU that supports only wired interrupts sets 
                            `fence_w_ip` bit is set to indicate completion of a 
                            `IOFENCE.C` command. An interrupt on setting 
                            `fence_w_ip` if not already pending 
                            (i.e. `ipsr.cip == 1`) and not masked 
                            (i.e. `cqsr.cie == 0`) and `fence_w_ip` is 0. 
                            To re-enable interrupts on `IOFENCE.C` completion
                            software should clear this bit by writing 1.
                            This bit is reserved if the IOMMU uses MSI. 
|15:12|`WPRI`   |WPRI     | Reserved
|16   |`cqon`   |RO       | The command-queue is active if `cqon` is 1.
                            IOMMU behavior on changing cqb when busy is 1 or 
                            `cqon` is 1 is implementation defined. The software 
                            recommended sequence to change `cqb` is to first 
                            disable the command-queue by clearing cqen and 
                            waiting for both `busy` and `cqon` to be 0 before 
                            changing the `cqb`.
|17   |`busy`   |RO       | A write to `cqcsr` may require the IOMMU to perform
                            many operations that may not occur synchronously 
                            to the write. When a write is observed by the 
                            `cqcsr`, the `busy` bit is set to 1.

                            When the `busy` bit is 1, behavior of additional 
                            writes to the `cqcsr` is implementation defined. 
                            Some implementations may ignore the second write and
                            others may perform the actions determined by the 
                            second write.

                            Software must verify that the busy bit is 0 before 
                            writing to the `cqcsr`. An IOMMU that can complete 
                            controls synchronously may hardwire this bit to 0.
|===
[NOTE]
====
Command-queue being empty does not imply that all commands fetched from the 
command-queue have been completed. When the command-queue is requested to be 
disabled, an implementation may either complete the already fetched commands 
or abort execution of those commands. Software must use an `IOFENCE.C` command 
to wait for all previous commands to be committed, if so desired, before 
turning off the command-queue.
====

[[FQCSR]]
=== Fault queue CSR (`fqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the fault-queue.

.Fault queue CSR register fields

[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'fqen'},
  {bits: 1, name: 'fie'},
  {bits: 6, name: 'WPRI'},
  {bits: 1, name: 'fqmf'},
  {bits: 1, name: 'fqof'},
  {bits: 6, name: 'WPRI'},
  {bits: 1, name: 'fqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'WPRI'},
  {bits: 4, name: 'Custom use'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits  |Field |Attribute | Description
|0     |`fqen`|RO        | The fault-queue enable bit enables the fault-queue 
                           when set to 1. 
                           Changing `fqen`  from 0 to 1, resets the `fqh` and 
                           `fqt` to 0 and clears `fqcsr` bits `fqmf` and `fqof`.
                           The fault-queue may take some time to be active
                           following setting the `fqen` to 1. When the fault 
                           queue is active, the `fqon` bit reads 1.  

                           When `fqen` is changed from 1 to 0, the fault-queue 
                           may stay active till in-flight fault-recording is 
                           completed. When the fault-queue is off, the `fqon` 
                           bit reads 0. The IOMMU guarantees that there are no 
                           in-flight implicit writes to the fault-queue in 
                           progress when `fqon` reads 0 and no new fault 
                           records will be written to the fault-queue. 
|1     |`fie` |RW        | Fault queue interrupt enable bit enables generation 
                           of interrupts from fault-queue when set to 1.
|7:2   |`WPRI`|WPRI      | Reserved
|8     |`fqmf`|RW1C      | The `fqmf` bit is set to 1 if the IOMMU encounters 
                           an access fault when storing a fault record to the 
                           fault queue. The fault-record that was attempted to 
                           be written is discarded and no more fault records 
                           are generated until software clears `fqmf` bit by 
                           writing 1 to the bit. An interrupt is generated if 
                           enabled and not already pending 
                           (i.e. `ispr.fip == 1`) and not masked 
                           (i.e. `fqsr.fie == 0`).
|9     |`fqof`|RW1C      | The fault-queue-overflow bit is set to 1 if the 
                            IOMMU needs to queue a fault record but the 
                            fault-queue is full (i.e., `fqh == fqt - 1`) 

                            The fault-record is discarded and no more fault 
                            records are generated till software clears `fqof` 
                            by writing 1 to the bit. An interrupt is generated 
                            if not already pending (i.e. `ispr.fip == 1`) and 
                            not masked (i.e. `fqsr.fie == 0`).
|10:15 |`WPRI`|WPRI      | Reserved
|16    |`fqon`|RO        | The fault-queue is active if `fqon` reads 1.
                           IOMMU behavior on changing `fqb` when `busy` is 1 
                           or `pqon` is 1 implementation defined. The 
                           recommended sequence to change `fqb` is to first 
                           disable the fault-queue by clearing `fqen` and 
                           waiting for both `busy` and `fqon` to be 0 before 
                           changing `fqb`.
|17    |`busy`|RO        | Write to `fqcsr` may require the IOMMU to perform 
                           many operations that may not occur synchronously to 
                           the write.
                           When a write is observed by the fqcsr, the `busy` 
                           bit is set to 1. When the `busy` bit is 1, behavior 
                           of additional writes to the `fqcsr` are 
                           implementation defined. Some implementations may 
                           ignore the second write and others may perform the 
                           actions determined by the second write.

                           Software should ensure that the `busy` bit is 0 
                           before writing to the `fqcsr`. An IOMMU that can 
                           complete controls synchronously may hardwire this 
                           bit to 0.
|27:18 |`WPRI`|WPRI      | Reserved
|31:28 |Custom|          | These bits are reserved for custom use.
|===

[[PQCSR]]
=== Page-request-queue CSR (`pqcsr`)

This 32-bits register (RW) is used to control the operations and report the
status of the page-request-queue.

.Page-request-queue CSR register fields

[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'pqen'},
  {bits: 1, name: 'pie'},
  {bits: 6, name: 'WPRI'},
  {bits: 1, name: 'pqmf'},
  {bits: 1, name: 'pqof'},
  {bits: 6, name: 'WPRI'},
  {bits: 1, name: 'pqon'},
  {bits: 1, name: 'busy'},
  {bits: 10, name: 'WPRI'},
  {bits: 4, name: 'Custom use'},
], config:{lanes: 4, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field   |Attribute | Description
|16     |`pqon`  |RO        | The page-request-enable bit enables the
                              page-request-queue when set to 1. 

                              Changing `pqen` from 0 to 1, resets the `pqh` 
                              and `pqt` to 0 and clears `pqcsr` bits `pqmf` and
                              `pqof` to 0. The page request queue may take 
                              some time to be active following setting the 
                              `pqen` to 1. When the page-request-queue is 
                              active, the `pqon` bit reads 1.

                              When `pqen` is changed from 1 to 0, the 
                              page-request-queue may stay active till in-flight 
                              page-request writes are completed. When the
                              page-request-queue turns off, the `pqon` bit 
                              reads 0.

                              When `pqon` reads 0, the IOMMU guarantees that 
                              there are no older in-flight implicit writes to 
                              the queue memory and no further implicit writes 
                              will be generated to the queue memory. 

                              The IOMMU may respond to “Page Request” messages 
                              received when page-request-queue is off or in 
                              the process of being turned off, as having 
                              encountered a catastrophic error as defined by 
                              the PCIe ATS specifications
|1      |`pie`   |RW        | The page-request-queue-interrupt-enable (`pie`) 
                              bit when set to 1, enables generation of 
                              interrupts from page request queue.
|7:2    |`WPRI`  |WPRI      | Reserved
|8      |`pqmf`  |RW1C      | The `pqmf` bit is set to 1 if the IOMMU 
                              encounters an access fault when storing a 
                              page-request message to the page-request-queue.

                              When `pqmf` is set to 1, an interrupt is 
                              generated if not already pending 
                              (i.e. `ipsr.pip == 1`) and not masked 
                              (i.e.  `pqsr.pie == 1`).

                              The page-request message that caused the `pqmf` 
                              or `pqof` error and all subsequent page-request 
                              messages are discarded till software clears the 
                              `pqof` and/or `pqmf` bits by writing 1 to it. 

                              The IOMMU may respond to “Page Request” messages 
                              that caused the `pqof` or `pqmf` bit to be set 
                              and all subsequent “Page Request” messages 
                              received while these bits are 1 as having 
                              encountered a catastrophic error as defined by 
                              the PCIe ATS specifications
|9      |`pqof`   |RW1C     | The page-request-queue-overflow bit is set to 1 
                              if the page-request queue overflows i.e. IOMMU 
                              needs to queue a page-request message but the 
                              page-request queue is full 
                              (i.e., `pqh == pqt - 1`). 

                              When `pqof` is set to 1, an interrupt is 
                              generated if not already pending 
                              (i.e. `ipsr.pip == 1`) and not masked 
                              (i.e. `pqsr.pie == 1`).

                              The page-request message that caused the `pqmf` 
                              or `pqof` error and all subsequent page-request 
                              messages are discarded till software clears the 
                              `pqof` and/or `pqmf` bits by writing 1 to it. 

                              The IOMMU may respond to “Page Request” messages 
                              that caused the `pqof` or `pqmf` bit to be set 
                              and all subsequent “Page Request” messages 
                              received while these bits are 1 as having 
                              encountered a catastrophic error as defined by 
                              the PCIe ATS specifications
|15:10  |`WPRI`   |WPRI     | Reserved
|16     |`pqon`   |RO       | The page-request is active when `pqon` reads 1.

                              IOMMU behavior on changing `pqb` when `busy` is 1
                              or `pqon` is 1 implementation defined. The 
                              recommended sequence to change `pqb` is to first 
                              disable the page-request queue by clearing `pqen`
                              and waiting for both `busy` and `pqon` to be 0 
                              before changing `pqb`.
|17     |`busy`   |RO       | A write to `pqcsr` may require the IOMMU to 
                              perform many operations that may not occur 
                              synchronously to the write. When a write is 
                              observed by the `pqcsr`, the `busy` bit is set 
                              to 1.

                              When the `busy` bit is 1, behavior of additional 
                              writes to the `pqcsr` are implementation defined.
                              Some implementations may ignore the second write 
                              and others may perform the actions determined by 
                              the second write. Software should ensure that the
                              `busy` bit is 0 before writing to the `pqcsr`.

                              An IOMMU that can complete controls synchronously
                              may hardwire this bit to 0
|18:27 |`WPRI`   |WPRI      | Reserved
|31:28 |Custom   |          | These bits are designated for custom use.
|===

[[IPSR]]
=== Interrupt pending status register (`ipsr`)
perrine

[[OVF]]
=== IOMMU performance monitoring counter overflow status (`iocountovf`)
Perrine

[[INH]]
=== IOMMU performance monitoring counter inhibit (`iocountinh`)
Perrine

[[CYC]]
=== IOMMU performance monitoring cycles counters (`iohpmcycles`)
Perrine

[[CTR]]
=== IOMMU performance monitoring counters (`iohpmctr1-31`)
Perrine

[[EVT]]
=== IOMMU performance monitoring event selection (`iohpmevt1-31`)
Perrine

[[ICVEC]]
=== Interrupt cause to vector register (`icvec`)
perrine

[[MSI]]
=== MSI configuration table (`msi_cfg_tbl`)
IOMMU that supports MSI implements a MSI configuration table that is indexed 
by the vector from `icvec` to determine a MSI table entry. Each MSI table 
entry for interrupt vector `x` has three registers `msi_addr_x`, `msi_data_x`, 
and `msi_vec_ctrl_x`. These registers are hard wired to 0 if the IOMMU does 
not support MSI.

.MSI configuration table structure
[width=100%]
[%header, cols="10,10,3"]
|===
|bit 63                 >s|                   bit 0|Byte Offset
2+^|Entry 0: Message address                       |+000h      
^|Entry 0: Vector Control  ^|Entry 0: Message Data |+008h      
2+^|Entry 1: Message address                       |+010h      
^|Entry 1: Vector Control  ^|Entry 1: Message Data |+018h      
2+^|...                                            |+020h     
|===

.`msi_addr_x` register fields
[wavedrom, , ]
....
{reg: [
  {bits: 2, name: '0'},
  {bits: 54, name: 'ADDR'},
  {bits: 8, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute |Description
|1:0    | 0    |RO     |Fixed to 0
|55:2   |`ADDR`|WARL   |Holds the 4-byte aligned MSI address.
|===


.`msi_data_x` register fields
[wavedrom, , ]
....
{reg: [
  {bits: 32, name: 'data'},
], config:{lanes: 1, hspace:1024}}
....

[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute |Description
|31:0   |`data`|Holds the 4-byte MSI data
|===


.`msi_vec_ctrl_x` register fields
[wavedrom, , ]
....
{reg: [
  {bits: 1, name: 'M'},
  {bits: 31, name: 'WPRI'},
], config:{lanes: 1, hspace:1024}}
....
[width=100%]
[%header, cols="^1,1,^1,6"]
|===
|Bits   |Field |Attribute | Description
|0      |`M`   |RW        | When the mask bit `M` is 1, the corresponding 
                            interrupt vector is masked and the IOMMU is 
                            prohibited from sending the associated message.
|15:1   |`WPRI`|WPRI      | Reserved for future use.
|===
